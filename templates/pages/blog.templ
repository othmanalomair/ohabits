package pages

import (
	"fmt"
	"ohabits/internal/database"
	"ohabits/templates/layouts"
)

// BlogListPage shows list of all blog posts
templ BlogListPage(user *database.User, posts []database.MarkdownNote, searchQuery string) {
	@layouts.Base("Ø§Ù„Ù…Ø¯ÙˆÙ†Ø©", user) {
		<div class="max-w-4xl mx-auto space-y-4">
			<!-- Header -->
			<div class="retro-card p-4 md:p-5">
				<div class="flex items-center justify-between mb-3">
					<h1 class="text-xl md:text-2xl font-bold text-retro-dark">Ø§Ù„Ù…Ø¯ÙˆÙ†Ø©</h1>
					<a href="/blog/new" class="anime-btn px-4 py-2 text-sm">
						+ Ù…Ø¯ÙˆÙ†Ø© Ø¬Ø¯ÙŠØ¯Ø©
					</a>
				</div>
				<!-- Search -->
				<div class="relative">
					<input
						type="text"
						name="q"
						value={ searchQuery }
						class="retro-input w-full pr-10 text-sm"
						placeholder="Ø§Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø¯ÙˆÙ†Ø§Øª..."
						dir="rtl"
						hx-get="/blog/search"
						hx-trigger="input changed delay:300ms, search"
						hx-target="#blog-posts"
						hx-swap="innerHTML"
						hx-indicator="#search-indicator"
					/>
					<div class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">
						<svg id="search-indicator" class="w-5 h-5 htmx-indicator animate-spin hidden" fill="none" viewBox="0 0 24 24">
							<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
							<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
						</svg>
						<svg class="w-5 h-5 search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						</svg>
					</div>
				</div>
			</div>

			<!-- Posts List -->
			<div id="blog-posts">
				@BlogPostsList(posts, searchQuery)
			</div>
		</div>
		<style>
			.htmx-request .search-icon { display: none; }
			.htmx-request .htmx-indicator { display: block !important; }
		</style>
	}
}

// BlogPostsList shows only the posts list (for HTMX partial updates)
templ BlogPostsList(posts []database.MarkdownNote, searchQuery string) {
	if len(posts) == 0 {
		<div class="retro-card p-8 text-center">
			<div class="text-6xl mb-4">ğŸ“</div>
			if searchQuery != "" {
				<p class="text-gray-500 mb-4">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø¨Ø­Ø«</p>
			} else {
				<p class="text-gray-500 mb-4">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¯ÙˆÙ†Ø§Øª Ø¨Ø¹Ø¯</p>
				<a href="/blog/new" class="anime-btn px-6 py-2 inline-block">
					Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒØªØ§Ø¨Ø©
				</a>
			}
		</div>
	} else {
		<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
			for _, post := range posts {
				<a
					href={ templ.SafeURL(fmt.Sprintf("/blog/%s", post.ID.String())) }
					class="retro-card p-4 block hover:border-primary-400 transition-colors"
				>
					<h2 class="font-bold text-lg text-retro-dark mb-2 line-clamp-1">{ post.Title }</h2>
					<p class="text-gray-500 text-sm line-clamp-2">{ truncateContent(post.Content, 100) }</p>
					<div class="flex items-center justify-between mt-3 text-xs text-gray-400">
						<div class="flex flex-wrap items-center gap-x-4 gap-y-1">
							<span>Ø£Ù†Ø´Ø¦: { post.CreatedAt.Format("2006/01/02") }</span>
							<span>ØªØ­Ø¯ÙŠØ«: { post.UpdatedAt.Format("01/02 - 15:04") }</span>
						</div>
						<span class="text-primary-500">Ù‚Ø±Ø§Ø¡Ø© â†</span>
					</div>
				</a>
			}
		</div>
	}
}

// BlogEditPage shows the blog editor
templ BlogEditPage(user *database.User, post *database.MarkdownNote) {
	@layouts.Base("ØªØ­Ø±ÙŠØ± Ø§Ù„Ù…Ø¯ÙˆÙ†Ø©", user) {
		<div class="max-w-4xl mx-auto flex flex-col blog-editor-container" x-data={ initBlogEditor(post) }>
			<!-- Toolbar -->
			<div class="retro-card p-3 mb-4 sticky top-0 z-10 flex-shrink-0">
				<div class="flex items-center justify-between flex-wrap gap-2">
					<div class="flex items-center gap-2">
						<a href="/blog" class="text-gray-500 hover:text-primary-500 p-2">
							<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
							</svg>
						</a>
						<span class="text-sm text-gray-400" x-text="saveStatus"></span>
					</div>
					<div class="flex items-center gap-2">
						<!-- Formatting buttons -->
						<button type="button" @click="insertFormat('**', '**')" class="p-2 hover:bg-primary-100 rounded" title="Ø¹Ø±ÙŠØ¶">
							<span class="font-bold">B</span>
						</button>
						<button type="button" @click="insertFormat('*', '*')" class="p-2 hover:bg-primary-100 rounded" title="Ù…Ø§Ø¦Ù„">
							<span class="italic">I</span>
						</button>
						<button type="button" @click="insertFormat('# ', '')" class="p-2 hover:bg-primary-100 rounded" title="Ø¹Ù†ÙˆØ§Ù†">
							<span class="font-bold">H</span>
						</button>
						<button type="button" @click="insertFormat('[', '](url)')" class="p-2 hover:bg-primary-100 rounded" title="Ø±Ø§Ø¨Ø·">
							ğŸ”—
						</button>
						<label class="p-2 hover:bg-primary-100 rounded cursor-pointer" title="ØµÙˆØ±Ø©">
							ğŸ“·
							<input type="file" accept="image/*" class="hidden" @change="uploadImage($event)"/>
						</label>
						<!-- AI Button with Dropdown -->
						<div class="relative" x-data="{ aiMenuOpen: false }">
							<button
								type="button"
								@click="aiMenuOpen = !aiMenuOpen"
								@click.away="aiMenuOpen = false"
								class="p-2 hover:bg-primary-100 rounded flex items-center gap-1"
								title="Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ"
								:class="{ 'bg-primary-100': aiMenuOpen }"
							>
								ğŸ¤–
								<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
								</svg>
							</button>
							<!-- Dropdown Menu -->
							<div
								x-show="aiMenuOpen"
								x-transition
								class="absolute left-0 md:right-0 md:left-auto mt-2 w-48 bg-white rounded-lg shadow-lg border-2 border-primary-200 py-2 z-50"
							>
								<button
									type="button"
									@click="aiFixText('improve'); aiMenuOpen = false"
									class="w-full text-right px-4 py-2 hover:bg-primary-50 flex items-center gap-2"
								>
									<span>âœ¨</span>
									<span>ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†Øµ</span>
								</button>
								<button
									type="button"
									@click="aiFixText('fix'); aiMenuOpen = false"
									class="w-full text-right px-4 py-2 hover:bg-primary-50 flex items-center gap-2"
								>
									<span>ğŸ“</span>
									<span>ØªØµØ­ÙŠØ­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡</span>
								</button>
								<button
									type="button"
									@click="aiFixText('simplify'); aiMenuOpen = false"
									class="w-full text-right px-4 py-2 hover:bg-primary-50 flex items-center gap-2"
								>
									<span>ğŸ¯</span>
									<span>ØªØ¨Ø³ÙŠØ· Ø§Ù„Ù†Øµ</span>
								</button>
								<button
									type="button"
									@click="openCustomPromptModal(); aiMenuOpen = false"
									class="w-full text-right px-4 py-2 hover:bg-primary-50 flex items-center gap-2"
								>
									<span>âœï¸</span>
									<span>ØªØ¹Ø¯ÙŠÙ„ Ù…Ø®ØµØµ</span>
								</button>
								<div class="border-t border-gray-200 my-1"></div>
								<button
									type="button"
									@click="aiGenerateTitles(); aiMenuOpen = false"
									class="w-full text-right px-4 py-2 hover:bg-primary-50 flex items-center gap-2"
								>
									<span>ğŸ’¡</span>
									<span>Ø§Ù‚ØªØ±Ø§Ø­ Ø¹Ù†Ø§ÙˆÙŠÙ†</span>
								</button>
							</div>
						</div>
						<div class="w-px h-6 bg-gray-300 mx-1"></div>
						<button type="button" @click="savePost()" class="anime-btn px-2 py-1.5 text-sm md:px-4">
							ğŸ’¾ <span class="hidden md:inline">Ø­ÙØ¸</span>
						</button>
						<a href={ templ.SafeURL(fmt.Sprintf("/blog/%s", post.ID.String())) } class="anime-btn px-2 py-1.5 text-sm bg-green-500 md:px-4">
							ğŸ‘ <span class="hidden md:inline">Ù…Ø¹Ø§ÙŠÙ†Ø©</span>
						</a>
						<button
							type="button"
							@click="deletePost()"
							class="p-2 hover:bg-red-100 rounded text-red-500"
							title="Ø­Ø°Ù Ø§Ù„Ù…Ø¯ÙˆÙ†Ø©"
						>
							ğŸ—‘ï¸
						</button>
						<div class="w-px h-6 bg-gray-300 mx-1"></div>
						<button
							type="button"
							@click="showAIModal = true"
							class="p-2 hover:bg-purple-100 rounded text-purple-600"
							title="Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ"
						>
							âœ¨
						</button>
					</div>
				</div>
			</div>

			<!-- AI Modal -->
			<div x-show="showAIModal" x-cloak class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" @click.self="closeAIModal()">
				<div class="retro-card p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
					<!-- Modal Header -->
					<div class="flex items-center justify-between mb-4">
						<h3 class="text-xl font-bold text-retro-dark">âœ¨ Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</h3>
						<button @click="closeAIModal()" class="text-gray-500 hover:text-gray-700">
							<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
							</svg>
						</button>
					</div>

					<!-- Mode Selection (only show if not showing diff) -->
					<template x-if="!showDiffPreview">
						<div class="space-y-4">
							<p class="text-gray-600 text-sm mb-4">Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:</p>

							<!-- Suggest Titles -->
							<button
								@click="suggestTitles()"
								:disabled="aiLoading"
								class="w-full p-4 text-right rounded-lg border-2 border-orange-200 hover:border-orange-400 hover:bg-orange-50 transition-colors disabled:opacity-50"
							>
								<div class="flex items-center gap-3">
									<span class="text-2xl">ğŸ’¡</span>
									<div>
										<div class="font-bold text-retro-dark">Ø§Ù‚ØªØ±Ø§Ø­ Ø¹Ù†Ø§ÙˆÙŠÙ†</div>
										<div class="text-sm text-gray-500">Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ 3 Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¬Ø°Ø§Ø¨Ø© Ù„Ù…Ø¯ÙˆÙ†ØªÙƒ</div>
									</div>
								</div>
							</button>

							<!-- Format Markdown -->
							<button
								@click="formatMarkdown()"
								:disabled="aiLoading"
								class="w-full p-4 text-right rounded-lg border-2 border-orange-200 hover:border-orange-400 hover:bg-orange-50 transition-colors disabled:opacity-50"
							>
								<div class="flex items-center gap-3">
									<span class="text-2xl">ğŸ“</span>
									<div>
										<div class="font-bold text-retro-dark">ØªÙ†Ø³ÙŠÙ‚ Markdown</div>
										<div class="text-sm text-gray-500">ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙˆØªØ­Ø³ÙŠÙ† Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©</div>
									</div>
								</div>
							</button>

							<!-- Custom Prompt -->
							<div class="p-4 rounded-lg border-2 border-orange-200">
								<div class="flex items-center gap-3 mb-3">
									<span class="text-2xl">âœï¸</span>
									<div>
										<div class="font-bold text-retro-dark">Ø·Ù„Ø¨ Ù…Ø®ØµØµ</div>
										<div class="text-sm text-gray-500">Ø§ÙƒØªØ¨ ØªØ¹Ù„ÙŠÙ…Ø§ØªÙƒ Ø§Ù„Ø®Ø§ØµØ©</div>
									</div>
								</div>
								<textarea
									x-model="customPrompt"
									class="w-full p-3 border rounded-lg text-sm resize-none"
									rows="2"
									placeholder="Ù…Ø«Ø§Ù„: Ø£Ø¶Ù Ù…Ù‚Ø¯Ù…Ø© Ø¬Ø°Ø§Ø¨Ø©ØŒ Ø§Ø®ØªØµØ± Ø§Ù„Ù†ØµØŒ ØªØ±Ø¬Ù… Ù„Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©..."
									dir="rtl"
								></textarea>
								<button
									@click="executeCustomPrompt()"
									:disabled="aiLoading || !customPrompt.trim()"
									class="mt-2 anime-btn px-4 py-2 text-sm w-full disabled:opacity-50"
								>
									ØªÙ†ÙÙŠØ°
								</button>
							</div>

							<!-- Loading indicator -->
							<div x-show="aiLoading" class="text-center py-4">
								<div class="inline-block animate-spin rounded-full h-8 w-8 border-4 border-orange-500 border-t-transparent"></div>
								<p class="mt-2 text-gray-600">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...</p>
							</div>

							<!-- Error message -->
							<div x-show="aiError" class="p-3 bg-red-100 text-red-700 rounded-lg text-sm" x-text="aiError"></div>
						</div>
					</template>

					<!-- Title Suggestions -->
					<template x-if="showTitleSuggestions && suggestedTitles.length > 0">
						<div class="space-y-4">
							<p class="text-gray-600 text-sm mb-4">Ø§Ø®ØªØ± Ø¹Ù†ÙˆØ§Ù†Ø§Ù‹ Ù…Ù† Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª:</p>
							<template x-for="(suggestion, index) in suggestedTitles" :key="index">
								<button
									@click="applyTitle(suggestion)"
									class="w-full p-4 text-right rounded-lg border-2 border-orange-200 hover:border-orange-400 hover:bg-orange-50 transition-colors"
								>
									<span x-text="suggestion"></span>
								</button>
							</template>
							<button @click="showTitleSuggestions = false; suggestedTitles = []" class="text-gray-500 hover:text-gray-700 text-sm">
								â† Ø±Ø¬ÙˆØ¹
							</button>
						</div>
					</template>

					<!-- Diff Preview -->
					<template x-if="showDiffPreview">
						<div class="space-y-4">
							<p class="text-gray-600 text-sm mb-2">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª:</p>

							<!-- Original -->
							<div class="p-3 bg-red-50 rounded-lg border border-red-200">
								<div class="text-xs text-red-600 mb-1 font-bold">Ø§Ù„Ø£ØµÙ„ÙŠ:</div>
								<pre class="text-sm whitespace-pre-wrap text-gray-700 max-h-40 overflow-y-auto" x-text="originalContent.substring(0, 500) + (originalContent.length > 500 ? '...' : '')"></pre>
							</div>

							<!-- Proposed -->
							<div class="p-3 bg-green-50 rounded-lg border border-green-200">
								<div class="text-xs text-green-600 mb-1 font-bold">Ø§Ù„Ù…Ù‚ØªØ±Ø­:</div>
								<pre class="text-sm whitespace-pre-wrap text-gray-700 max-h-40 overflow-y-auto" x-text="proposedContent.substring(0, 500) + (proposedContent.length > 500 ? '...' : '')"></pre>
							</div>

							<!-- Actions -->
							<div class="flex gap-3">
								<button @click="applyProposedChanges()" class="flex-1 anime-btn py-2">
									âœ“ ØªØ·Ø¨ÙŠÙ‚
								</button>
								<button @click="rejectProposedChanges()" class="flex-1 py-2 rounded-lg border-2 border-gray-300 hover:bg-gray-100">
									âœ— Ø±ÙØ¶
								</button>
							</div>
						</div>
					</template>
				</div>
			</div>

			<!-- Editor -->
			<div class="retro-card p-4 md:p-6 flex-1 flex flex-col min-h-0">
				<!-- Title -->
				<input
					type="text"
					x-model="title"
					x-ref="titleInput"
					@input="scheduleAutoSave()"
					class="w-full text-2xl font-bold text-retro-dark bg-transparent border-none outline-none mb-4 placeholder-gray-400 flex-shrink-0"
					placeholder="Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ø¯ÙˆÙ†Ø©..."
					dir="rtl"
				/>

				<!-- Content -->
				<textarea
					x-ref="editor"
					x-model="content"
					@input="scheduleAutoSave()"
					class="w-full flex-1 text-retro-dark bg-transparent border-none outline-none resize-none leading-relaxed text-lg"
					placeholder="Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒØªØ§Ø¨Ø© Ù‡Ù†Ø§...

ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙ†Ø³ÙŠÙ‚ Markdown:
# Ø¹Ù†ÙˆØ§Ù† ÙƒØ¨ÙŠØ±
## Ø¹Ù†ÙˆØ§Ù† Ø£ØµØºØ±
**Ù†Øµ Ø¹Ø±ÙŠØ¶**
*Ù†Øµ Ù…Ø§Ø¦Ù„*
[Ù†Øµ Ø§Ù„Ø±Ø§Ø¨Ø·](Ø§Ù„Ø±Ø§Ø¨Ø·)
![ÙˆØµÙ Ø§Ù„ØµÙˆØ±Ø©](Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø©)"
					dir="rtl"
				></textarea>
			</div>

			<!-- AI Loading Overlay -->
			<div
				x-show="aiLoading"
				x-transition
				class="fixed inset-0 bg-black/50 flex items-center justify-center z-50"
			>
				<div class="bg-white rounded-xl p-6 shadow-xl text-center">
					<div class="animate-spin text-4xl mb-3">ğŸ¤–</div>
					<p class="text-retro-dark font-bold" x-text="aiLoadingMessage">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...</p>
				</div>
			</div>

			<!-- AI Titles Modal -->
			<div
				x-show="showTitlesModal"
				x-transition
				class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4"
				@click.self="showTitlesModal = false"
			>
				<div class="bg-white rounded-xl p-6 shadow-xl w-full max-w-md">
					<h3 class="text-xl font-bold text-retro-dark mb-4">ğŸ’¡ Ø¹Ù†Ø§ÙˆÙŠÙ† Ù…Ù‚ØªØ±Ø­Ø©</h3>
					<div class="space-y-2">
						<template x-for="(t, index) in suggestedTitles" :key="index">
							<button
								type="button"
								@click="selectTitle(t)"
								class="w-full text-right p-3 rounded-lg border-2 border-primary-200 hover:border-primary-400 hover:bg-primary-50 transition-colors"
							>
								<span x-text="t"></span>
							</button>
						</template>
					</div>
					<button
						type="button"
						@click="showTitlesModal = false"
						class="w-full mt-4 p-2 text-gray-500 hover:text-gray-700"
					>
						Ø¥Ù„ØºØ§Ø¡
					</button>
				</div>
			</div>

			<!-- AI Preview Modal -->
			<div
				x-show="showPreviewModal"
				x-transition
				class="fixed inset-0 bg-black/50 flex items-end sm:items-center justify-center z-50 p-0 sm:p-4"
				@click.self="showPreviewModal = false"
			>
				<div class="bg-white rounded-t-xl sm:rounded-xl shadow-xl w-full sm:max-w-2xl max-h-[85vh] sm:max-h-[90vh] flex flex-col">
					<!-- Header -->
					<div class="p-4 border-b border-gray-100 flex-shrink-0">
						<h3 class="text-lg font-bold text-retro-dark">ğŸ¤– Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­</h3>
					</div>

					<!-- Scrollable Content -->
					<div class="flex-1 overflow-y-auto p-4 space-y-4">
						<div>
							<label class="block text-sm font-bold text-primary-700 mb-2">Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ:</label>
							<div class="retro-input bg-gray-50 max-h-[120px] sm:max-h-[150px] overflow-y-auto p-3 text-sm text-gray-600 whitespace-pre-wrap" dir="rtl" x-text="originalText"></div>
						</div>

						<div>
							<label class="block text-sm font-bold text-primary-700 mb-2">Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ù‚ØªØ±Ø­:</label>
							<div class="retro-input bg-green-50 border-green-300 max-h-[120px] sm:max-h-[150px] overflow-y-auto p-3 text-sm text-retro-dark whitespace-pre-wrap" dir="rtl" x-text="suggestedText"></div>
						</div>
					</div>

					<!-- Fixed Buttons -->
					<div class="p-4 border-t border-gray-100 flex-shrink-0 flex gap-3">
						<button type="button" @click="acceptSuggestion()" class="anime-btn flex-1 py-3 text-sm">âœ“ Ù‚Ø¨ÙˆÙ„</button>
						<button type="button" @click="showPreviewModal = false" class="flex-1 py-3 text-sm border-2 border-gray-300 rounded-xl text-gray-600 hover:bg-gray-50 font-bold">Ø¥Ù„ØºØ§Ø¡</button>
					</div>
				</div>
			</div>

			<!-- AI Custom Prompt Modal -->
			<div
				x-show="showCustomPromptModal"
				x-transition
				class="fixed inset-0 bg-black/50 flex items-end sm:items-center justify-center z-50 p-0 sm:p-4"
				@click.self="showCustomPromptModal = false"
			>
				<div class="bg-white rounded-t-xl sm:rounded-xl shadow-xl w-full sm:max-w-md max-h-[85vh] flex flex-col">
					<!-- Header -->
					<div class="p-4 border-b border-gray-100 flex-shrink-0">
						<h3 class="text-lg font-bold text-retro-dark">âœï¸ ØªØ¹Ø¯ÙŠÙ„ Ù…Ø®ØµØµ</h3>
					</div>

					<!-- Content -->
					<div class="flex-1 overflow-y-auto p-4 space-y-4">
						<div>
							<label class="block text-sm font-bold text-primary-700 mb-2">Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø­Ø¯Ø¯:</label>
							<div class="retro-input bg-gray-50 max-h-[80px] overflow-y-auto p-3 text-sm text-gray-600 whitespace-pre-wrap" dir="rtl" x-text="originalText"></div>
						</div>

						<div>
							<label class="block text-sm font-bold text-primary-700 mb-2">Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª:</label>
							<textarea x-model="customPromptText" class="retro-input w-full h-20 resize-none text-sm"
								placeholder="Ù…Ø«Ø§Ù„: Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù†Øµ Ø£ÙƒØ«Ø± Ø±Ø³Ù…ÙŠØ©..." dir="rtl"></textarea>
						</div>
					</div>

					<!-- Fixed Buttons -->
					<div class="p-4 border-t border-gray-100 flex-shrink-0 flex gap-3">
						<button type="button" @click="submitCustomPrompt()" :disabled="!customPromptText.trim()"
							class="anime-btn flex-1 py-3 text-sm" :class="{ 'opacity-50 cursor-not-allowed': !customPromptText.trim() }">
							ğŸ¤– ØªØ·Ø¨ÙŠÙ‚
						</button>
						<button type="button" @click="showCustomPromptModal = false; customPromptText = ''"
							class="flex-1 py-3 text-sm border-2 border-gray-300 rounded-xl text-gray-600 hover:bg-gray-50 font-bold">Ø¥Ù„ØºØ§Ø¡</button>
					</div>
				</div>
			</div>
		</div>

		<style>
			[x-cloak] { display: none !important; }
			html, body {
				overflow: hidden;
				height: 100%;
			}
			.blog-editor-container {
				height: calc(100dvh - 60px - 48px); /* 60px header, 48px main padding (py-6) */
				min-height: 400px;
			}
			@media (max-width: 768px) {
				.blog-editor-container {
					height: calc(100dvh - 56px - 48px); /* smaller header on mobile */
				}
			}
		</style>
	}
}

// BlogViewPage shows a single blog post rendered
templ BlogViewPage(user *database.User, post *database.MarkdownNote) {
	@layouts.Base(post.Title, user) {
		<div class="max-w-2xl mx-auto">
			<!-- Header -->
			<div class="retro-card p-4 md:p-6">
				<div class="flex items-center justify-between mb-4">
					<a href="/blog" class="text-gray-500 hover:text-primary-500">
						â† Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…Ø¯ÙˆÙ†Ø§Øª
					</a>
					<a href={ templ.SafeURL(fmt.Sprintf("/blog/%s/edit", post.ID.String())) } class="anime-btn px-4 py-1.5 text-sm">
						âœï¸ ØªØ­Ø±ÙŠØ±
					</a>
				</div>

				<h1 class="text-2xl md:text-3xl font-bold text-retro-dark mb-2">{ post.Title }</h1>
				<p class="text-sm text-gray-400 mb-6">
					Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: { post.UpdatedAt.Format("2006/01/02 - 15:04") }
				</p>

				<!-- Rendered Content -->
				<div class="prose prose-lg max-w-none blog-content" dir="rtl">
					@templ.Raw(renderMarkdown(post.Content))
				</div>
			</div>
		</div>

		<style>
			.blog-content h1 {
				font-size: 1.75rem;
				font-weight: bold;
				color: #3D2314;
				margin-top: 1.5rem;
				margin-bottom: 0.75rem;
				border-bottom: 2px solid #F97316;
				padding-bottom: 0.5rem;
			}
			.blog-content h2 {
				font-size: 1.5rem;
				font-weight: bold;
				color: #3D2314;
				margin-top: 1.25rem;
				margin-bottom: 0.5rem;
			}
			.blog-content h3 {
				font-size: 1.25rem;
				font-weight: bold;
				color: #3D2314;
				margin-top: 1rem;
				margin-bottom: 0.5rem;
			}
			.blog-content p {
				margin-bottom: 1rem;
				line-height: 1.8;
			}
			.blog-content a {
				color: #F97316;
				text-decoration: underline;
			}
			.blog-content a:hover {
				color: #EA580C;
			}
			.blog-content img,
			.blog-content .blog-image {
				display: block;
				max-width: 100%;
				height: auto;
				border-radius: 8px;
				margin: 1rem auto;
				border: 2px solid #FFECD1;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
			}
			.blog-content ul {
				margin-bottom: 1rem;
				padding-right: 1.5rem;
				list-style-type: disc;
			}
			.blog-content ol {
				margin-bottom: 1rem;
				padding-right: 1.5rem;
				list-style-type: decimal;
			}
			.blog-content li {
				margin-bottom: 0.5rem;
				margin-right: 1rem;
			}
			.blog-content hr {
				border: none;
				border-top: 2px solid #FFECD1;
				margin: 1.5rem 0;
			}
			.blog-content blockquote {
				border-right: 4px solid #F97316;
				padding-right: 1rem;
				margin: 1rem 0;
				color: #666;
				font-style: italic;
			}
			.blog-content code {
				background: #FFF5E6;
				padding: 0.125rem 0.375rem;
				border-radius: 4px;
				font-family: monospace;
			}
			.blog-content pre {
				background: #3D2314;
				color: #FFF5E6;
				padding: 1rem;
				border-radius: 8px;
				overflow-x: auto;
				margin: 1rem 0;
			}
			.blog-content pre code {
				background: transparent;
				padding: 0;
			}
		</style>
	}
}

func truncateContent(content string, maxLen int) string {
	// Remove markdown syntax for preview
	content = removeMarkdownSyntax(content)
	// Use runes to properly handle UTF-8 characters (Arabic, etc.)
	runes := []rune(content)
	if len(runes) <= maxLen {
		return content
	}
	return string(runes[:maxLen]) + "..."
}

func removeMarkdownSyntax(s string) string {
	// Simple removal of common markdown
	result := s
	// Remove headers
	for i := 6; i >= 1; i-- {
		prefix := ""
		for j := 0; j < i; j++ {
			prefix += "#"
		}
		result = replaceAll(result, prefix+" ", "")
	}
	// Remove bold/italic
	result = replaceAll(result, "**", "")
	result = replaceAll(result, "*", "")
	result = replaceAll(result, "__", "")
	result = replaceAll(result, "_", "")
	return result
}

func replaceAll(s, old, new string) string {
	for {
		idx := indexOf(s, old)
		if idx == -1 {
			break
		}
		s = s[:idx] + new + s[idx+len(old):]
	}
	return s
}

func indexOf(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}

func renderMarkdown(content string) string {
	if content == "" {
		return "<p class=\"text-gray-400\">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø­ØªÙˆÙ‰</p>"
	}

	// Simple markdown to HTML conversion
	lines := splitLines(content)
	var result string
	inCodeBlock := false
	inUnorderedList := false
	inOrderedList := false

	for _, line := range lines {
		// Code blocks
		if hasPrefix(line, "```") {
			if inCodeBlock {
				result += "</code></pre>"
				inCodeBlock = false
			} else {
				// Close any open lists
				if inUnorderedList {
					result += "</ul>"
					inUnorderedList = false
				}
				if inOrderedList {
					result += "</ol>"
					inOrderedList = false
				}
				result += "<pre><code>"
				inCodeBlock = true
			}
			continue
		}

		if inCodeBlock {
			result += escapeHTML(line) + "\n"
			continue
		}

		// Trim line for checking but keep original for content
		trimmedLine := trimSpaces(line)

		// Headers
		if hasPrefix(trimmedLine, "### ") {
			closeOpenLists(&result, &inUnorderedList, &inOrderedList)
			result += "<h3>" + processInline(trimmedLine[4:]) + "</h3>"
			continue
		}
		if hasPrefix(trimmedLine, "## ") {
			closeOpenLists(&result, &inUnorderedList, &inOrderedList)
			result += "<h2>" + processInline(trimmedLine[3:]) + "</h2>"
			continue
		}
		if hasPrefix(trimmedLine, "# ") {
			closeOpenLists(&result, &inUnorderedList, &inOrderedList)
			result += "<h1>" + processInline(trimmedLine[2:]) + "</h1>"
			continue
		}

		// Unordered list items (- item or * item)
		if hasPrefix(trimmedLine, "- ") || hasPrefix(trimmedLine, "* ") {
			if inOrderedList {
				result += "</ol>"
				inOrderedList = false
			}
			if !inUnorderedList {
				result += "<ul>"
				inUnorderedList = true
			}
			result += "<li>" + processInline(trimmedLine[2:]) + "</li>"
			continue
		}

		// Ordered list items (1. item, 2. item, etc.)
		if isOrderedListItem(trimmedLine) {
			if inUnorderedList {
				result += "</ul>"
				inUnorderedList = false
			}
			if !inOrderedList {
				result += "<ol>"
				inOrderedList = true
			}
			// Find the content after "N. "
			idx := indexOfRune(trimmedLine, '.')
			if idx != -1 && idx+2 <= len(trimmedLine) {
				result += "<li>" + processInline(trimmedLine[idx+2:]) + "</li>"
			}
			continue
		}

		// Close lists if we hit a non-list item
		closeOpenLists(&result, &inUnorderedList, &inOrderedList)

		// Blockquote
		if hasPrefix(trimmedLine, "> ") {
			result += "<blockquote>" + processInline(trimmedLine[2:]) + "</blockquote>"
			continue
		}

		// Horizontal rule (---, ***, ___, or more)
		if isHorizontalRule(trimmedLine) {
			result += "<hr>"
			continue
		}

		// Empty line - add spacing
		if trimmedLine == "" {
			result += "<div class=\"h-4\"></div>"
			continue
		}

		// Check if line is just an image
		if hasPrefix(trimmedLine, "![") && hasSuffix(trimmedLine, ")") {
			result += "<div class=\"my-4\">" + processInline(trimmedLine) + "</div>"
			continue
		}

		// Regular paragraph
		result += "<p>" + processInline(trimmedLine) + "</p>"
	}

	// Close any remaining open elements
	if inCodeBlock {
		result += "</code></pre>"
	}
	closeOpenLists(&result, &inUnorderedList, &inOrderedList)

	return result
}

func closeOpenLists(result *string, inUnorderedList *bool, inOrderedList *bool) {
	if *inUnorderedList {
		*result += "</ul>"
		*inUnorderedList = false
	}
	if *inOrderedList {
		*result += "</ol>"
		*inOrderedList = false
	}
}

func isOrderedListItem(line string) bool {
	// Check if line starts with a number followed by ". "
	runes := []rune(line)
	i := 0
	// Skip digits
	for i < len(runes) && runes[i] >= '0' && runes[i] <= '9' {
		i++
	}
	// Must have at least one digit, followed by ". "
	if i > 0 && i+1 < len(runes) && runes[i] == '.' && runes[i+1] == ' ' {
		return true
	}
	return false
}

func indexOfRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	return -1
}

func trimSpaces(s string) string {
	runes := []rune(s)
	start := 0
	end := len(runes)
	// Trim leading whitespace
	for start < end && (runes[start] == ' ' || runes[start] == '\t' || runes[start] == '\r') {
		start++
	}
	// Trim trailing whitespace (including \r for Windows line endings)
	for end > start && (runes[end-1] == ' ' || runes[end-1] == '\t' || runes[end-1] == '\r') {
		end--
	}
	return string(runes[start:end])
}

func hasSuffix(s, suffix string) bool {
	return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}

// isHorizontalRule checks if a line is a horizontal rule (3+ of -, *, or _)
func isHorizontalRule(line string) bool {
	if len(line) < 3 {
		return false
	}
	// Remove all spaces
	cleaned := ""
	for _, r := range line {
		if r != ' ' && r != '\t' {
			cleaned += string(r)
		}
	}
	if len(cleaned) < 3 {
		return false
	}
	// Check if all characters are the same (-, *, or _)
	first := rune(cleaned[0])
	if first != '-' && first != '*' && first != '_' {
		return false
	}
	for _, r := range cleaned {
		if r != first {
			return false
		}
	}
	return true
}

func processInline(text string) string {
	// Process images and links BEFORE escaping HTML (URLs may contain special chars)
	// Images: ![alt](url)
	text = processImages(text)

	// Links: [text](url)
	text = processLinks(text)

	// Now escape HTML for the remaining text (but not the already-processed HTML tags)
	text = escapeHTMLSelective(text)

	// Bold: **text**
	text = processBold(text)

	// Italic: *text*
	text = processItalic(text)

	// Inline code: `code`
	text = processInlineCode(text)

	return text
}

// escapeHTMLSelective escapes HTML but preserves already-created HTML tags
func escapeHTMLSelective(s string) string {
	result := ""
	runes := []rune(s)
	i := 0
	for i < len(runes) {
		// Check if we're at an HTML tag we created (img, a)
		if runes[i] == '<' {
			// Check if it's one of our tags
			remaining := string(runes[i:])
			if hasPrefix(remaining, "<img ") || hasPrefix(remaining, "<a ") ||
				hasPrefix(remaining, "</a>") {
				// Find the closing >
				for i < len(runes) {
					result += string(runes[i])
					if runes[i] == '>' {
						i++
						break
					}
					i++
				}
				continue
			}
			// Not our tag, escape it
			result += "&lt;"
			i++
			continue
		}
		// Escape other special characters
		switch runes[i] {
		case '>':
			result += "&gt;"
		case '&':
			result += "&amp;"
		case '"':
			result += "&quot;"
		default:
			result += string(runes[i])
		}
		i++
	}
	return result
}

func processImages(text string) string {
	runes := []rune(text)
	result := ""
	i := 0
	for i < len(runes) {
		if i+1 < len(runes) && runes[i] == '!' && runes[i+1] == '[' {
			// Find closing bracket
			altEnd := -1
			for j := i + 2; j < len(runes); j++ {
				if runes[j] == ']' {
					altEnd = j
					break
				}
			}
			if altEnd != -1 && altEnd+1 < len(runes) && runes[altEnd+1] == '(' {
				urlEnd := -1
				for j := altEnd + 2; j < len(runes); j++ {
					if runes[j] == ')' {
						urlEnd = j
						break
					}
				}
				if urlEnd != -1 {
					alt := string(runes[i+2 : altEnd])
					url := string(runes[altEnd+2 : urlEnd])
					result += "<img src=\"" + url + "\" alt=\"" + alt + "\" class=\"blog-image\" loading=\"lazy\">"
					i = urlEnd + 1
					continue
				}
			}
		}
		result += string(runes[i])
		i++
	}
	return result
}

func processLinks(text string) string {
	runes := []rune(text)
	result := ""
	i := 0
	for i < len(runes) {
		if runes[i] == '[' {
			// Find closing bracket
			textEnd := -1
			for j := i + 1; j < len(runes); j++ {
				if runes[j] == ']' {
					textEnd = j
					break
				}
			}
			if textEnd != -1 && textEnd+1 < len(runes) && runes[textEnd+1] == '(' {
				urlEnd := -1
				for j := textEnd + 2; j < len(runes); j++ {
					if runes[j] == ')' {
						urlEnd = j
						break
					}
				}
				if urlEnd != -1 {
					linkText := string(runes[i+1 : textEnd])
					url := string(runes[textEnd+2 : urlEnd])
					result += "<a href=\"" + url + "\" target=\"_blank\" rel=\"noopener\">" + linkText + "</a>"
					i = urlEnd + 1
					continue
				}
			}
		}
		result += string(runes[i])
		i++
	}
	return result
}

func processBold(text string) string {
	runes := []rune(text)
	result := ""
	i := 0
	for i < len(runes) {
		if i+1 < len(runes) && runes[i] == '*' && runes[i+1] == '*' {
			// Find closing **
			end := -1
			for j := i + 2; j+1 < len(runes); j++ {
				if runes[j] == '*' && runes[j+1] == '*' {
					end = j
					break
				}
			}
			if end != -1 {
				result += "<strong>" + string(runes[i+2:end]) + "</strong>"
				i = end + 2
				continue
			}
		}
		result += string(runes[i])
		i++
	}
	return result
}

func processItalic(text string) string {
	runes := []rune(text)
	result := ""
	i := 0
	for i < len(runes) {
		if runes[i] == '*' && (i == 0 || runes[i-1] != '*') && (i+1 >= len(runes) || runes[i+1] != '*') {
			// Find closing *
			end := -1
			for j := i + 1; j < len(runes); j++ {
				if runes[j] == '*' && (j+1 >= len(runes) || runes[j+1] != '*') {
					end = j
					break
				}
			}
			if end != -1 {
				result += "<em>" + string(runes[i+1:end]) + "</em>"
				i = end + 1
				continue
			}
		}
		result += string(runes[i])
		i++
	}
	return result
}

func processInlineCode(text string) string {
	runes := []rune(text)
	result := ""
	i := 0
	for i < len(runes) {
		if runes[i] == '`' {
			// Find closing `
			end := -1
			for j := i + 1; j < len(runes); j++ {
				if runes[j] == '`' {
					end = j
					break
				}
			}
			if end != -1 {
				result += "<code>" + string(runes[i+1:end]) + "</code>"
				i = end + 1
				continue
			}
		}
		result += string(runes[i])
		i++
	}
	return result
}

func splitLines(s string) []string {
	runes := []rune(s)
	var lines []string
	start := 0
	for i := 0; i < len(runes); i++ {
		if runes[i] == '\n' {
			lines = append(lines, string(runes[start:i]))
			start = i + 1
		}
	}
	if start < len(runes) {
		lines = append(lines, string(runes[start:]))
	}
	return lines
}

func hasPrefix(s, prefix string) bool {
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}

func escapeHTML(s string) string {
	result := ""
	for _, c := range s {
		switch c {
		case '<':
			result += "&lt;"
		case '>':
			result += "&gt;"
		case '&':
			result += "&amp;"
		case '"':
			result += "&quot;"
		default:
			result += string(c)
		}
	}
	return result
}

func initBlogEditor(post *database.MarkdownNote) string {
	return fmt.Sprintf(`{
		postId: '%s',
		title: %q,
		content: %q,
		saveStatus: 'Ù…Ø­ÙÙˆØ¸',
		autoSaveTimer: null,
		aiLoading: false,
		aiLoadingMessage: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...',
		showTitlesModal: false,
		suggestedTitles: [],
		showPreviewModal: false,
		showCustomPromptModal: false,
		originalText: '',
		suggestedText: '',
		selectionStart: 0,
		selectionEnd: 0,
		customPromptText: '',

		// AI Assistant state
		showAIModal: false,
		aiLoading: false,
		aiError: '',
		customPrompt: '',
		showDiffPreview: false,
		showTitleSuggestions: false,
		suggestedTitles: [],
		originalContent: '',
		proposedContent: '',

		closeAIModal() {
			this.showAIModal = false;
			this.aiLoading = false;
			this.aiError = '';
			this.showDiffPreview = false;
			this.showTitleSuggestions = false;
			this.suggestedTitles = [];
			this.originalContent = '';
			this.proposedContent = '';
			this.customPrompt = '';
		},

		async suggestTitles() {
			if (!this.content.trim()) {
				this.aiError = 'ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù…Ø­ØªÙˆÙ‰ Ø£ÙˆÙ„Ø§Ù‹';
				return;
			}
			this.aiLoading = true;
			this.aiError = '';
			try {
				const response = await fetch('/api/ai/suggest-titles', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ content: this.content })
				});
				const data = await response.json();
				if (data.status === 'success') {
					this.suggestedTitles = data.titles;
					this.showTitleSuggestions = true;
				} else {
					this.aiError = data.error || 'Ø­Ø¯Ø« Ø®Ø·Ø£';
				}
			} catch (e) {
				this.aiError = 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„';
			}
			this.aiLoading = false;
		},

		applyTitle(title) {
			this.title = title;
			this.scheduleAutoSave();
			this.closeAIModal();
		},

		async formatMarkdown() {
			if (!this.content.trim()) {
				this.aiError = 'ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù…Ø­ØªÙˆÙ‰ Ø£ÙˆÙ„Ø§Ù‹';
				return;
			}
			this.aiLoading = true;
			this.aiError = '';
			try {
				const response = await fetch('/api/ai/format-markdown', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ content: this.content })
				});
				const data = await response.json();
				if (data.status === 'success') {
					this.originalContent = this.content;
					this.proposedContent = data.formattedContent;
					this.showDiffPreview = true;
				} else {
					this.aiError = data.error || 'Ø­Ø¯Ø« Ø®Ø·Ø£';
				}
			} catch (e) {
				this.aiError = 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„';
			}
			this.aiLoading = false;
		},

		async executeCustomPrompt() {
			if (!this.content.trim()) {
				this.aiError = 'ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù…Ø­ØªÙˆÙ‰ Ø£ÙˆÙ„Ø§Ù‹';
				return;
			}
			if (!this.customPrompt.trim()) {
				this.aiError = 'ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø·Ù„Ø¨';
				return;
			}
			this.aiLoading = true;
			this.aiError = '';
			try {
				const response = await fetch('/api/ai/custom-prompt', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ content: this.content, prompt: this.customPrompt })
				});
				const data = await response.json();
				if (data.status === 'success') {
					this.originalContent = this.content;
					this.proposedContent = data.result;
					this.showDiffPreview = true;
				} else {
					this.aiError = data.error || 'Ø­Ø¯Ø« Ø®Ø·Ø£';
				}
			} catch (e) {
				this.aiError = 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„';
			}
			this.aiLoading = false;
		},

		applyProposedChanges() {
			this.content = this.proposedContent;
			this.scheduleAutoSave();
			this.closeAIModal();
		},

		rejectProposedChanges() {
			this.showDiffPreview = false;
			this.originalContent = '';
			this.proposedContent = '';
		},

		scheduleAutoSave() {
			this.saveStatus = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';
			clearTimeout(this.autoSaveTimer);
			this.autoSaveTimer = setTimeout(() => {
				this.savePost();
			}, 2000);
		},

		async savePost() {
			const formData = new FormData();
			formData.append('title', this.title);
			formData.append('content', this.content);

			try {
				const response = await fetch('/blog/' + this.postId + '/save', {
					method: 'POST',
					body: formData
				});

				if (response.ok) {
					const data = await response.json();
					this.saveStatus = 'ØªÙ… Ø§Ù„Ø­ÙØ¸ âœ“';
					setTimeout(() => {
						this.saveStatus = 'Ù…Ø­ÙÙˆØ¸';
					}, 2000);
				} else {
					this.saveStatus = 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸!';
				}
			} catch (e) {
				this.saveStatus = 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸!';
			}
		},

		insertFormat(before, after) {
			const textarea = this.$refs.editor;
			const start = textarea.selectionStart;
			const end = textarea.selectionEnd;
			const text = this.content;
			const selectedText = text.substring(start, end);

			// Ø­ÙØ¸ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø³ÙƒØ±ÙˆÙ„ Ù‚Ø¨Ù„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
			const scrollTop = textarea.scrollTop;
			const scrollLeft = textarea.scrollLeft;

			this.content = text.substring(0, start) + before + selectedText + after + text.substring(end);
			this.scheduleAutoSave();

			// Ø§Ø³ØªØ®Ø¯Ø§Ù… requestAnimationFrame Ù„Ø¶Ù…Ø§Ù† Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ø±Ø³Ù…
			requestAnimationFrame(() => {
				// Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„ÙÙˆÙƒØ³
				textarea.focus();
				// Ø¥Ø±Ø¬Ø§Ø¹ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø³ÙƒØ±ÙˆÙ„
				textarea.scrollTop = scrollTop;
				textarea.scrollLeft = scrollLeft;
				// ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙƒØ±Ø³Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
				const newCursorPos = start + before.length + selectedText.length;
				textarea.setSelectionRange(newCursorPos, newCursorPos);

				// Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„: Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ÙƒØ±Ø³Ø± Ù…Ø±Ø¦ÙŠ
				// Ø¨Ø¯ÙˆÙ† ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø´Ø§Ø´Ø© ÙƒØ«ÙŠØ±Ø§Ù‹
				setTimeout(() => {
					textarea.scrollTop = scrollTop;
				}, 50);
			});
		},

		async uploadImage(event) {
			const file = event.target.files[0];
			if (!file) return;

			this.saveStatus = 'Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...';

			const formData = new FormData();
			formData.append("image", file);
			// Include note_id for blog_images table
			if (this.postId) {
				formData.append("note_id", this.postId);
			}

			try {
				const response = await fetch('/blog/upload-image', {
					method: 'POST',
					body: formData
				});

				if (response.ok) {
					const data = await response.json();
					const imageMarkdown = '\n![](' + data.position_marker + ')\n';

					const textarea = this.$refs.editor;
					const start = textarea.selectionStart;
					const scrollTop = textarea.scrollTop;

					this.content = this.content.substring(0, start) + imageMarkdown + this.content.substring(start);

					this.saveStatus = 'ØªÙ… Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© âœ“';
					this.scheduleAutoSave();

					// Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø³ÙƒØ±ÙˆÙ„ Ø¨Ø¹Ø¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø©
					requestAnimationFrame(() => {
						textarea.focus();
						textarea.scrollTop = scrollTop;
						const newPos = start + imageMarkdown.length;
						textarea.setSelectionRange(newPos, newPos);
					});
				} else {
					this.saveStatus = 'Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©!';
				}
			} catch (e) {
				this.saveStatus = 'Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©!';
			}

			event.target.value = '';
		},

		async deletePost() {
			if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¯ÙˆÙ†Ø©ØŸ')) return;

			try {
				const response = await fetch('/blog/' + this.postId, {
					method: 'DELETE'
				});

				if (response.ok) {
					window.location.href = '/blog';
				}
			} catch (e) {
				alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù');
			}
		},

		async aiFixText(action) {
			const textarea = this.$refs.editor;
			const start = textarea.selectionStart;
			const end = textarea.selectionEnd;

			// Check if text is selected
			if (start === end) {
				alert('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªØ­Ø³ÙŠÙ†Ù‡');
				return;
			}

			const selectedText = this.content.substring(start, end);

			// Save selection info for later use
			this.selectionStart = start;
			this.selectionEnd = end;
			this.originalText = selectedText;

			// Set loading state
			this.aiLoading = true;
			this.aiLoadingMessage = action === 'improve' ? 'Ø¬Ø§Ø±ÙŠ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†Øµ...' :
									action === 'fix' ? 'Ø¬Ø§Ø±ÙŠ ØªØµØ­ÙŠØ­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡...' :
									'Ø¬Ø§Ø±ÙŠ ØªØ¨Ø³ÙŠØ· Ø§Ù„Ù†Øµ...';

			try {
				const response = await fetch('/api/ai/fix-text', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						text: selectedText,
						action: action
					})
				});

				const data = await response.json();

				if (data.error) {
					alert(data.error);
					return;
				}

				// Show preview modal instead of direct replacement
				this.suggestedText = data.text;
				this.showPreviewModal = true;

			} catch (e) {
				alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ');
				console.error(e);
			} finally {
				this.aiLoading = false;
			}
		},

		acceptSuggestion() {
			const textarea = this.$refs.editor;
			const scrollTop = textarea.scrollTop;

			// Replace the selected text with the suggested version
			this.content = this.content.substring(0, this.selectionStart) + this.suggestedText + this.content.substring(this.selectionEnd);
			this.scheduleAutoSave();

			// Close modal and reset state
			this.showPreviewModal = false;

			// Restore scroll position and selection
			requestAnimationFrame(() => {
				textarea.focus();
				textarea.scrollTop = scrollTop;
				const newEnd = this.selectionStart + this.suggestedText.length;
				textarea.setSelectionRange(this.selectionStart, newEnd);
			});
		},

		openCustomPromptModal() {
			const textarea = this.$refs.editor;
			const start = textarea.selectionStart;
			const end = textarea.selectionEnd;

			// Check if text is selected
			if (start === end) {
				alert('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ØªØ¹Ø¯ÙŠÙ„Ù‡');
				return;
			}

			const selectedText = this.content.substring(start, end);

			// Save selection info
			this.selectionStart = start;
			this.selectionEnd = end;
			this.originalText = selectedText;
			this.customPromptText = '';

			// Show custom prompt modal
			this.showCustomPromptModal = true;
		},

		async submitCustomPrompt() {
			if (!this.customPromptText.trim()) return;

			// Close custom prompt modal
			this.showCustomPromptModal = false;

			// Set loading state
			this.aiLoading = true;
			this.aiLoadingMessage = 'Ø¬Ø§Ø±ÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„...';

			try {
				const response = await fetch('/api/ai/fix-text', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						text: this.originalText,
						action: 'custom',
						customPrompt: this.customPromptText
					})
				});

				const data = await response.json();

				if (data.error) {
					alert(data.error);
					return;
				}

				// Show preview modal
				this.suggestedText = data.text;
				this.showPreviewModal = true;

			} catch (e) {
				alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ');
				console.error(e);
			} finally {
				this.aiLoading = false;
				this.customPromptText = '';
			}
		},

		async aiGenerateTitles() {
			if (!this.content.trim()) {
				alert('Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø¯ÙˆÙ†Ø© Ø£ÙˆÙ„Ø§Ù‹');
				return;
			}

			this.aiLoading = true;
			this.aiLoadingMessage = 'Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ†...';

			try {
				const response = await fetch('/api/ai/generate-title', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						content: this.content
					})
				});

				const data = await response.json();

				if (data.error) {
					alert(data.error);
					return;
				}

				if (data.titles && data.titles.length > 0) {
					this.suggestedTitles = data.titles;
					this.showTitlesModal = true;
				} else {
					alert('Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø¹Ù†Ø§ÙˆÙŠÙ†. Ø¬Ø±Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
				}

			} catch (e) {
				alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ');
				console.error(e);
			} finally {
				this.aiLoading = false;
			}
		},

		selectTitle(title) {
			this.title = title;
			this.showTitlesModal = false;
			this.scheduleAutoSave();

			// Focus on title input
			requestAnimationFrame(() => {
				this.$refs.titleInput.focus();
			});
		}
	}`, post.ID.String(), post.Title, post.Content)
}
